# Raven Development Rules

## Source of Truth

**`docs/SPECIFICATION.md` is the authoritative specification for all Raven behavior.**

- Before implementing any feature, verify it matches the specification
- After implementing a feature, update the specification if behavior changed
- If the spec and code diverge, the spec is correct—fix the code
- When proposing new features, update the spec first, then implement
- The spec documents both "what" and "why" for design decisions
- You should be able to read the spec and fully understand how the system works

## Design Philosophy

### Explicit Over Magic

Prefer explicit configuration and behavior over implicit "magic":

- **Good**: User defines types in `schema.yaml`, those are the available types
- **Bad**: Auto-detecting types based on content patterns without user configuration
- **Good**: Requiring `id=` for explicit `::type()` declarations so IDs are predictable
- **Acceptable**: Section IDs auto-generated from slugified heading text (documented, predictable, overridable with `::type(id=...)`)
- **Bad**: Undocumented auto-generation that users can't predict or override

Configuration should be discoverable and documented. A user reading `schema.yaml` should understand exactly what types and traits are available.

### Simple, Unambiguous Syntax

The type/object/trait syntax must be:

- **Visually distinct**: `::type()` for objects, `@trait` or `@trait(value)` for traits, `[[ref]]` for links
- **Predictable**: Same syntax always means the same thing
- **Non-conflicting**: Syntax should not collide with common markdown patterns
- **Parseable**: Regular expressions or simple parsers can extract elements reliably

**Traits are single-valued**: Each trait takes at most one value. Use multiple traits instead of one trait with multiple fields: `@due(2025-02-01) @priority(high)` not `@task(due=..., priority=...)`.

Avoid syntax that requires context to interpret or that could be confused with other markdown conventions.

### User-Controlled Schema

Configuration defines everything—nothing is hidden:

- All available types come from `schema.yaml` (plus built-in `page`, `section`, `date`)
- All available traits come from `schema.yaml`
- All saved queries come from `raven.yaml`
- Built-in types:
  - `page` and `section`: Can be customized or extended by the user
  - `date`: Locked (cannot be modified). Used for daily notes (YYYY-MM-DD.md files). Use traits for daily note metadata.
- Vault behavior (daily directory, queries) configured in `raven.yaml`
- Field validation, defaults—all in the schema

**No hidden behavior**: If the system does something, it should be traceable to configuration or documented built-in behavior.

### General System, User Workflow

Raven is a **general system** for adding typed structure to markdown:

- **We provide**: Types, traits, references, tags, querying, indexing
- **User decides**: What types to create, what traits to use, folder structure, workflows

Avoid building opinionated workflows into the core:

- **Good**: Atomic traits like `@due`, `@status`, `@priority` that users combine
- **Bad**: Composite `@task` trait that assumes a specific task model
- **Good**: Saved queries in `raven.yaml` that users define for their workflows
- **Bad**: Built-in "task management" with hard-coded status flows
- **Good**: `rvn trait due --value past` for ad-hoc queries
- **Bad**: Built-in "project dashboard" that assumes specific type structures

The tool should be a foundation that users build their workflows on top of.

## Code Standards

### Go Conventions

- Follow standard Go project layout (`cmd/`, `internal/`)
- Use `go fmt` and `go vet`
- Prefer stdlib where sufficient (e.g., `encoding/json`, `path/filepath`)
- Error messages should be actionable and include context

### Testing

- Unit tests for parser components (frontmatter, markdown, traits, refs)
- Integration tests using `testdata/` vault
- Test edge cases: empty files, malformed syntax, unicode, code blocks

### CLI Design

- Commands should be discoverable via `--help`
- Error messages should suggest fixes
- Output should be human-readable by default, with `--json` for scripting
- Respect the vault boundary—never operate outside configured vault

## Implementation Checklist

When adding a feature:

1. [ ] Verify feature is documented in `docs/SPECIFICATION.md`
2. [ ] If new, add to spec with rationale in Design Decisions section
3. [ ] Implement with explicit configuration (no magic)
4. [ ] Add tests covering normal and edge cases
5. [ ] Update README.md if user-facing behavior changes
6. [ ] Ensure CLI help text is accurate

When fixing a bug:

1. [ ] Check if spec describes expected behavior
2. [ ] If spec is unclear, clarify it first
3. [ ] Fix code to match spec
4. [ ] Add regression test
