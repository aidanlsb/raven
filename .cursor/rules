# Raven Development Rules

## FUNDAMENTAL PRINCIPLE: Plain Text is the Source of Truth

**Raven is a plain-text-first system. The user's markdown files and `schema.yaml` are the ONLY source of truth.**

The SQLite database (`.raven/index.sqlite`) is a **derived, disposable cache**:

- It can be deleted at any time without data loss
- It is fully recreated by `rvn reindex` from the markdown files
- It should NEVER contain data that doesn't exist in the text files
- It exists solely for fast querying—not for storage

**This means:**
- All mutations to user data must write to markdown files, not just the database
- The database is rebuilt, never migrated with user data
- Users can sync their vault via git/Dropbox/iCloud without syncing `.raven/`
- If the database is corrupted or outdated, delete it and reindex

**Never:**
- Store user-created content only in the database
- Require the database to recover user data
- Treat the database as authoritative over the text files

This principle is NON-NEGOTIABLE. It's what makes Raven portable, trustworthy, and future-proof.

---

## Specification Source of Truth

**`docs/SPECIFICATION.md` is the authoritative specification for all Raven behavior.**

- Before implementing any feature, verify it matches the specification
- After implementing a feature, update the specification if behavior changed
- If the spec and code diverge, the spec is correct—fix the code
- When proposing new features, update the spec first, then implement
- The spec documents both "what" and "why" for design decisions
- You should be able to read the spec and fully understand how the system works

## Design Philosophy

### Explicit Over Magic

Prefer explicit configuration and behavior over implicit "magic":

- **Good**: User defines types in `schema.yaml`, those are the available types
- **Bad**: Auto-detecting types based on content patterns without user configuration
- **Good**: Requiring `id=` for explicit `::type()` declarations so IDs are predictable
- **Acceptable**: Section IDs auto-generated from slugified heading text (documented, predictable, overridable with `::type(id=...)`)
- **Bad**: Undocumented auto-generation that users can't predict or override

Configuration should be discoverable and documented. A user reading `schema.yaml` should understand exactly what types and traits are available.

### Simple, Unambiguous Syntax

The type/object/trait syntax must be:

- **Visually distinct**: `::type()` for objects, `@trait` or `@trait(value)` for traits, `[[ref]]` for links
- **Predictable**: Same syntax always means the same thing
- **Non-conflicting**: Syntax should not collide with common markdown patterns
- **Parseable**: Regular expressions or simple parsers can extract elements reliably

**Traits are single-valued**: Each trait takes at most one value. Use multiple traits instead of one trait with multiple fields: `@due(2025-02-01) @priority(high)` not `@task(due=..., priority=...)`.

Avoid syntax that requires context to interpret or that could be confused with other markdown conventions.

### User-Controlled Schema

Configuration defines everything—nothing is hidden:

- All available types come from `schema.yaml` (plus built-in `page`, `section`, `date`)
- All available traits come from `schema.yaml`
- All saved queries come from `raven.yaml`
- Built-in types:
  - `page` and `section`: Can be customized or extended by the user
  - `date`: Locked (cannot be modified). Used for daily notes (YYYY-MM-DD.md files). Use traits for daily note metadata.
- Vault behavior (daily directory, queries) configured in `raven.yaml`
- Field validation, defaults—all in the schema

**Traits are universal**: Traits defined globally in `schema.yaml` can be used:
- **Inline** anywhere in content: `@due(2025-02-01) Send the report`
- **In frontmatter** if the type declares them: `due: 2025-02-01`

Types declare which traits are valid in their frontmatter using the `traits` field. This enables structured data (frontmatter traits on objects) and flexible annotation (inline traits on content) to coexist.

**No hidden behavior**: If the system does something, it should be traceable to configuration or documented built-in behavior.

### Schema Changes Must Preserve Data Integrity

**Any schema modification that would result in invalid or incomplete data must be blocked until the user resolves the underlying issues.**

This means:
- **Removing a required field**: Blocked if any objects of that type exist (they would become invalid)
- **Making a field required**: Blocked if any objects lack that field
- **Changing field type** (e.g., string → date): Blocked if existing values don't match the new type
- **Removing a type**: Allowed, but objects become `page` type (warn, require `--force`)
- **Removing a trait**: Allowed, but existing trait instances remain in files (warn, require `--force`)

**Why strict?** Raven is a personal knowledge system—data integrity is paramount. It's better to require the user to fix 3 files before a schema change than to silently create 3 invalid objects. We start strict and can relax if it becomes burdensome, but correctness comes first.

**Resolution workflow**:
```bash
$ rvn schema update field person email --required
Error: 3 person objects lack 'email' field:
  - people/alice.md
  - people/bob.md
  - people/carol.md

Add the field to these files, then retry.
Hint: Use 'rvn type person --json' to list all person objects.
```

**Audit logging**: All schema mutations are logged to `.raven/audit.log`.

### General System, User Workflow

Raven is a **general system** for adding typed structure to markdown:

- **We provide**: Types, traits, references, tags, querying, indexing
- **User decides**: What types to create, what traits to use, folder structure, workflows

Avoid building opinionated workflows into the core:

- **Good**: Atomic traits like `@due`, `@status`, `@priority` that users combine
- **Bad**: Composite `@task` trait that assumes a specific task model
- **Good**: Saved queries in `raven.yaml` that users define for their workflows
- **Bad**: Built-in "task management" with hard-coded status flows
- **Good**: `rvn trait due --value past` for ad-hoc queries
- **Bad**: Built-in "project dashboard" that assumes specific type structures

The tool should be a foundation that users build their workflows on top of.

### Vault-Scoped Operations

**All Raven functionality must operate exclusively within the explicitly identified vault.**

This is a security and integrity principle:

- **File operations**: Read, write, create, delete—only within the vault directory
- **Path validation**: Always verify resolved paths remain within vault boundaries before any operation
- **No escape**: Symlinks, `../` paths, or any mechanism that could reach outside the vault must be blocked
- **Explicit boundaries**: The vault path is set via config or CLI flag—never inferred from current directory alone

Implementation pattern:
```go
// Always validate paths before operations
absVault, _ := filepath.Abs(vaultPath)
absTarget, _ := filepath.Abs(targetPath)
if !strings.HasPrefix(absTarget, absVault+string(filepath.Separator)) {
    return fmt.Errorf("cannot operate outside vault: %s", targetPath)
}
```

This protects users from:
- Accidental writes to system files
- Malicious references escaping the vault
- Unintended side effects from misconfigured paths

## Code Standards

### General Best Practices
- Make sure that core functionality is implemented once, not duplicated. And then reused throughout the app as needed. For example, in an earlier version we had a few different implementations of new page creation -- this should always be a single implementation that is called from different entrypoints as needed

### No Dead Code
- Delete unused functions immediately—don't leave "wrapper" functions that just call another function
- If you add a `*WithJSON` variant, remove the original if it's no longer called
- Run `go build` after deletions to catch unused imports
- If a function is only used in one place and is trivial, consider inlining it

### Package Boundaries
Keep functionality in the right package:
- **`internal/config/`**: All config loading AND saving (e.g., `SaveVaultConfig`)
- **`internal/cli/`**: Command handlers only—no business logic that could be reused
- **`internal/pages/`**: Page creation, slugification, path handling
- **`internal/vault/`**: Vault-level utilities (walking files, date parsing, editor)
- **`internal/index/`**: Database operations

**Signs of misplaced code:**
- A function in `cli/` that doesn't use Cobra or command context
- A function in one CLI file used by another CLI file → move to shared package
- Config writing in `cli/` instead of `config/`

### Command Registry Pattern
The **command registry** (`internal/commands/registry.go`) is the single source of truth for all CLI commands:
- Add new commands by adding an entry to the registry
- MCP tools are auto-generated from the registry
- `rvn schema commands` reads from the registry
- This ensures CLI and MCP never diverge

When adding a new command:
1. Add the command metadata to `internal/commands/registry.go`
2. Create the Cobra command handler in `internal/cli/`
3. The MCP tool will be automatically available

### MCP → CLI Argument Passing Standard

The MCP server calls CLI commands via `exec.Command`. **Argument ordering is strictly enforced** to prevent parsing issues:

```
[command] [subcommand] [--flags] [--json] [--] [positional args] [key=value pairs]
```

**Rules:**
1. **Command/subcommand first**: e.g., `edit`, `schema add type`
2. **All flags next**: `--confirm`, `--filter today`, etc.
3. **`--json` always added**: MCP responses must be JSON
4. **`--` separator always added**: Prevents positional args starting with `-` from being parsed as flags
5. **Positional args after `--`**: In registry-defined order
6. **Key-value pairs last**: For commands like `set` that take `field=value` args

**Why this matters:**
- User content can contain `-` characters (e.g., `- list item`, `--heading--`)
- Without `--`, Cobra interprets these as flags
- This standard applies to ALL commands, no exceptions

**No special cases allowed.** If a command doesn't fit this pattern, refactor the command to fit—don't add edge case handling in the MCP layer.

### Go Conventions

- Follow standard Go project layout (`cmd/`, `internal/`)
- Use `go fmt` and `go vet`
- Prefer stdlib where sufficient (e.g., `encoding/json`, `path/filepath`)
- Error messages should be actionable and include context

### Testing

- Unit tests for parser components (frontmatter, markdown, traits, refs)
- Integration tests using `testdata/` vault
- Test edge cases: empty files, malformed syntax, unicode, code blocks

### CLI Design

- Commands should be discoverable via `--help`
- Error messages should suggest fixes
- Output should be human-readable by default, with `--json` for scripting
- Enforce vault-scoped operations (see "Vault-Scoped Operations" above)

## Implementation Checklist

When adding a feature:

1. [ ] Verify feature is documented in `docs/SPECIFICATION.md`
2. [ ] If new, add to spec with rationale in Design Decisions section
3. [ ] Implement with explicit configuration (no magic)
4. [ ] Add tests covering normal and edge cases
5. [ ] Update README.md if user-facing behavior changes
6. [ ] Ensure CLI help text is accurate

When fixing a bug:

1. [ ] Check if spec describes expected behavior
2. [ ] If spec is unclear, clarify it first
3. [ ] Fix code to match spec
4. [ ] Add regression test
