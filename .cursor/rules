# Raven Development Rules

## FUNDAMENTAL PRINCIPLE: Plain Text is the Source of Truth

**Raven is a plain-text-first system. The user's markdown files, `schema.yaml`, and `raven.yaml` are the ONLY source of truth for a vault.**

The SQLite database (`.raven/index.sqlite`) is a **derived, disposable cache**:

- It can be deleted at any time without data loss
- It is fully recreated by `rvn reindex` from the markdown files
- It should NEVER contain data that doesn't exist in the text files, outside of conveniences
- It exists solely for fast querying—not for storage

**This means:**
- All mutations to user data must write to markdown files, not just the database
- The database is rebuilt, never migrated with user data
- Users can sync their vault via git/Dropbox/iCloud without syncing `.raven/`
- If the database is corrupted or outdated, delete it and reindex

**Never:**
- Store user-created content only in the database
- Require the database to recover user data
- Treat the database as authoritative over the text files

This principle is NON-NEGOTIABLE. It's what makes Raven portable, trustworthy, and future-proof.

---

## Specification Source of Truth

**`docs/reference/*` is the authoritative specification for Raven behavior.**

- Before implementing any feature, verify it matches the specification
- After implementing a feature, update the relevant reference doc(s) if behavior changed
- If docs and code diverge, update docs to match intended behavior (or fix code if it’s a regression)
- When proposing new features, update the spec first, then implement
- Reference docs document “what”; design docs in `docs/design/*` document “why”
- Start at `docs/README.md` for the docs index

## Design Philosophy

### Explicit Over Magic

Prefer explicit configuration and behavior over implicit "magic":

- **Good**: User defines types in `schema.yaml`, those are the available types
- **Bad**: Auto-detecting types based on content patterns without user configuration
- **Good**: IDs auto-generated from slugified heading text (consistent with sections, documented, predictable)
- **Good**: Optional `id=` override for explicit `::type()` declarations when users need custom IDs
- **Bad**: Undocumented auto-generation that users can't predict or override

Configuration should be discoverable and documented. A user reading `schema.yaml` should understand exactly what types and traits are available.

### Simple, Unambiguous Syntax

The type/object/trait syntax must be:

- **Visually distinct**: `::type()` for objects, `@trait` or `@trait(value)` for traits, `[[ref]]` for links
- **Predictable**: Same syntax always means the same thing
- **Non-conflicting**: Syntax should not collide with common markdown patterns
- **Parseable**: Regular expressions or simple parsers can extract elements reliably

**Traits are single-valued**: Each trait takes at most one value. Use multiple traits instead of one trait with multiple fields: `@due(2025-02-01) @priority(high)` not `@task(due=..., priority=...)`.

Avoid syntax that requires context to interpret or that could be confused with other markdown conventions.

### User-Controlled Schema

Configuration defines everything—nothing is hidden:

- All available types come from `schema.yaml` (plus built-in `page`, `section`, `date`)
- All available traits come from `schema.yaml`
- All saved queries come from `raven.yaml`
- Built-in types:
  - `page` and `section`: Can be customized or extended by the user
  - `date`: Locked (cannot be modified). Used for daily notes (YYYY-MM-DD.md files). Use traits for daily note metadata.
- Vault behavior (daily directory, queries) configured in `raven.yaml`
- Field validation, defaults—all in the schema

**Traits are universal**: Traits defined globally in `schema.yaml` can be used:
- **Inline** anywhere in content: `@due(2025-02-01) Send the report`
- **In frontmatter** if the type declares them: `due: 2025-02-01`

Types declare which traits are valid in their frontmatter using the `traits` field. This enables structured data (frontmatter traits on objects) and flexible annotation (inline traits on content) to coexist.

**No hidden behavior**: If the system does something, it should be traceable to configuration or documented built-in behavior.

### Schema Changes Must Preserve Data Integrity

**Any schema modification that would result in invalid or incomplete data must be blocked until the user resolves the underlying issues.**

This means:
- **Removing a required field**: Blocked if any objects of that type exist (they would become invalid)
- **Making a field required**: Blocked if any objects lack that field
- **Changing field type** (e.g., string → date): Blocked if existing values don't match the new type
- **Removing a type**: Allowed, but objects become `page` type (warn, require `--force`)
- **Removing a trait**: Allowed, but existing trait instances remain in files (warn, require `--force`)

**Why strict?** Raven is a personal knowledge system—data integrity is paramount. It's better to require the user to fix 3 files before a schema change than to silently create 3 invalid objects. We start strict and can relax if it becomes burdensome, but correctness comes first.

**Resolution workflow**:
```bash
$ rvn schema update field person email --required
Error: 3 person objects lack 'email' field:
  - people/freya.md
  - people/thor.md
  - people/loki.md

Add the field to these files, then retry.
Hint: Use 'rvn type person --json' to list all person objects.
```

**Audit logging**: All schema mutations are logged to `.raven/audit.log`.

### General System, User Workflow

Raven is a **general system** for adding typed structure to markdown:

- **We provide**: Types, traits, references, tags, querying, indexing
- **User decides**: What types to create, what traits to use, folder structure, workflows

Avoid building opinionated workflows into the core:

- **Good**: Atomic traits like `@due`, `@status`, `@priority` that users combine
- **Bad**: Composite `@task` trait that assumes a specific task model
- **Good**: Saved queries in `raven.yaml` that users define for their workflows
- **Bad**: Built-in "task management" with hard-coded status flows
- **Good**: `rvn trait due --value past` for ad-hoc queries
- **Bad**: Built-in "project dashboard" that assumes specific type structures

The tool should be a foundation that users build their workflows on top of.

### Vault-Scoped Operations

**All Raven functionality must operate exclusively within the explicitly identified vault.**

This is a security and integrity principle:

- **File operations**: Read, write, create, delete—only within the vault directory
- **Path validation**: Always verify resolved paths remain within vault boundaries before any operation
- **No escape**: Symlinks, `../` paths, or any mechanism that could reach outside the vault must be blocked
- **Explicit boundaries**: The vault path is set via config or CLI flag—never inferred from current directory alone

Implementation pattern:
```go
// Always validate paths before operations
absVault, _ := filepath.Abs(vaultPath)
absTarget, _ := filepath.Abs(targetPath)
if !strings.HasPrefix(absTarget, absVault+string(filepath.Separator)) {
    return fmt.Errorf("cannot operate outside vault: %s", targetPath)
}
```

This protects users from:
- Accidental writes to system files
- Malicious references escaping the vault
- Unintended side effects from misconfigured paths

## Code Standards

### General Best Practices
- Make sure that core functionality is implemented once, not duplicated. And then reused throughout the app as needed. For example, in an earlier version we had a few different implementations of new page creation -- this should always be a single implementation that is called from different entrypoints as needed

### No Dead Code
- Delete unused functions immediately—don't leave "wrapper" functions that just call another function
- If you add a `*WithJSON` variant, remove the original if it's no longer called
- Run `go build` after deletions to catch unused imports
- If a function is only used in one place and is trivial, consider inlining it

### Package Boundaries
Keep functionality in the right package:
- **`internal/config/`**: All config loading AND saving (e.g., `SaveVaultConfig`)
- **`internal/cli/`**: Command handlers only—no business logic that could be reused
- **`internal/pages/`**: Page creation, slugification, path handling
- **`internal/vault/`**: Vault-level utilities (walking files, date parsing, editor)
- **`internal/index/`**: Database operations

**Signs of misplaced code:**
- A function in `cli/` that doesn't use Cobra or command context
- A function in one CLI file used by another CLI file → move to shared package
- Config writing in `cli/` instead of `config/`

### Command Registry Pattern
The **command registry** (`internal/commands/registry.go`) is the single source of truth for all CLI commands:
- Add new commands by adding an entry to the registry
- MCP tools are auto-generated from the registry
- `rvn schema commands` reads from the registry
- This ensures CLI and MCP never diverge

When adding a new command:
1. Add the command metadata to `internal/commands/registry.go`
2. Create the Cobra command handler in `internal/cli/`
3. The MCP tool will be automatically available

### MCP → CLI Argument Passing Standard

The MCP server calls CLI commands via `exec.Command`. **Argument ordering is strictly enforced** to prevent parsing issues:

```
[command] [subcommand] [--flags] [--json] [--] [positional args] [key=value pairs]
```

**Rules:**
1. **Command/subcommand first**: e.g., `edit`, `schema add type`
2. **All flags next**: `--confirm`, `--filter today`, etc.
3. **`--json` always added**: MCP responses must be JSON
4. **`--` separator always added**: Prevents positional args starting with `-` from being parsed as flags
5. **Positional args after `--`**: In registry-defined order
6. **Key-value pairs last**: For commands like `set` that take `field=value` args

**Why this matters:**
- User content can contain `-` characters (e.g., `- list item`, `--heading--`)
- Without `--`, Cobra interprets these as flags
- This standard applies to ALL commands, no exceptions

**No special cases allowed.** If a command doesn't fit this pattern, refactor the command to fit—don't add edge case handling in the MCP layer.

### Go Conventions

- Follow standard Go project layout (`cmd/`, `internal/`)
- Use `go fmt` and `go vet`
- Prefer stdlib where sufficient (e.g., `encoding/json`, `path/filepath`)
- Error messages should be actionable and include context

### Testing

- Unit tests for parser components (frontmatter, markdown, traits, refs)
- Integration tests using `testdata/` vault
- Test edge cases: empty files, malformed syntax, unicode, code blocks

### CLI Design

- Commands should be discoverable via `--help`
- Error messages should suggest fixes
- Output should be human-readable by default, with `--json` for scripting
- Enforce vault-scoped operations (see "Vault-Scoped Operations" above)

## Implementation Checklist

When adding a feature:

1. [ ] Verify feature is documented in `docs/reference/*` (or add docs first)
2. [ ] If new, add/extend reference docs and (if needed) design rationale in `docs/design/*`
3. [ ] Implement with explicit configuration (no magic)
4. [ ] Add tests covering normal and edge cases
5. [ ] Update README.md if user-facing behavior changes
6. [ ] Ensure CLI help text is accurate

When fixing a bug:

1. [ ] Check if spec describes expected behavior
2. [ ] If spec is unclear, clarify it first
3. [ ] Fix code to match spec
4. [ ] Add regression test

---

## Documentation Sync (After Code Changes)

**After making code changes, always check if documentation needs updating.**

### File-to-Doc Mapping

| When you modify... | Update... |
|-------------------|-----------|
| `internal/cli/*.go` (new/modified commands) | `docs/guide/cli.md` (usage) and/or relevant `docs/reference/*` |
| `internal/commands/registry.go` / `internal/mcp/*` | `docs/reference/mcp.md` |
| `internal/check/validator.go` (new validations) | relevant `docs/reference/*` pages (file format / schema / config) |
| `internal/index/database.go` (schema/index changes) | `docs/design/database.md` (high level) |
| `internal/query/*` (query syntax) | `docs/reference/query-language.md` |
| `internal/workflow/*` | `docs/reference/workflows.md` |
| User-facing behavior changes | `README.md` |

### Quick Checklist

After completing code changes, ask:

1. **Does this change user-facing behavior?** → Update `README.md` and/or `docs/guide/*`
2. **Did I add/modify a CLI command?** → Update command examples and flags
3. **Did I add/modify validation in `rvn check`?** → Update error/warning lists
4. **Did I add a new MCP tool?** → Update MCP Tools table
5. **Is the feature mentioned in Implementation Phases?** → Mark as complete if done

### Verification

Run `rvn --help` and compare documented commands against actual behavior. Check that documented flags match implementation.

---

## Documentation & Examples: Norse Mythology Theme

**All examples in documentation, tests, and code should use Norse mythology characters and concepts.**

This provides a consistent, memorable, and clearly fictional naming convention throughout the codebase.

### Character Reference

Use these names when examples need people:

| Name | Role | Use For |
|------|------|---------|
| **Freya** | Goddess of love/beauty | Primary person example |
| **Thor** | God of thunder | Secondary person |
| **Odin** | All-father | Authority figure, someone to call/meet |
| **Loki** | Trickster god | Person in agent interactions |
| **Sif** | Thor's wife | Example for slugification (simple name) |
| **Baldur** | God of light | Missing reference examples |
| **Heimdall** | Guardian of Bifrost | Security/gatekeeper examples |

### Realm & Place Reference

| Name | Description | Use For |
|------|-------------|---------|
| **Asgard** | Home of the gods | Main realm, like a company |
| **Midgard** | Earth/human realm | Secondary context |
| **Bifrost** | Rainbow bridge | Project names, connections |
| **Vanaheim** | Home of the Vanir | Alternative realm |
| **Yggdrasil** | World tree | System/infrastructure names |

### Email Domain

Use `@asgard.realm` for email examples:
- `freya@asgard.realm`
- `thor@asgard.realm`

### Example Patterns

```markdown
# Good examples
rvn new person "Freya"
rvn add "Call Odin about the Bifrost"
rvn backlinks people/freya

# In documentation
Met with [[people/thor]] about [[projects/bifrost]].

# In tests
{"name": "Freya", "email": "freya@asgard.realm"}
```

### Why Norse Mythology?

1. **Clearly fictional**: No confusion with real people
2. **Memorable**: Rich characters people recognize
3. **Consistent theme**: Easy to extend with more names
4. **Fun**: Makes docs more engaging than "Alice and Bob"
