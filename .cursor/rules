# Raven Development Rules

## FUNDAMENTAL PRINCIPLE: Plain Text is the Source of Truth

**Raven is a plain-text-first system. The user's markdown files and `schema.yaml` are the ONLY source of truth.**

The SQLite database (`.raven/index.sqlite`) is a **derived, disposable cache**:

- It can be deleted at any time without data loss
- It is fully recreated by `rvn reindex` from the markdown files
- It should NEVER contain data that doesn't exist in the text files
- It exists solely for fast querying—not for storage

**This means:**
- All mutations to user data must write to markdown files, not just the database
- The database is rebuilt, never migrated with user data
- Users can sync their vault via git/Dropbox/iCloud without syncing `.raven/`
- If the database is corrupted or outdated, delete it and reindex

**Never:**
- Store user-created content only in the database
- Require the database to recover user data
- Treat the database as authoritative over the text files

This principle is NON-NEGOTIABLE. It's what makes Raven portable, trustworthy, and future-proof.

---

## Specification Source of Truth

**`docs/SPECIFICATION.md` is the authoritative specification for all Raven behavior.**

- Before implementing any feature, verify it matches the specification
- After implementing a feature, update the specification if behavior changed
- If the spec and code diverge, the spec is correct—fix the code
- When proposing new features, update the spec first, then implement
- The spec documents both "what" and "why" for design decisions
- You should be able to read the spec and fully understand how the system works

## Design Philosophy

### Explicit Over Magic

Prefer explicit configuration and behavior over implicit "magic":

- **Good**: User defines types in `schema.yaml`, those are the available types
- **Bad**: Auto-detecting types based on content patterns without user configuration
- **Good**: Requiring `id=` for explicit `::type()` declarations so IDs are predictable
- **Acceptable**: Section IDs auto-generated from slugified heading text (documented, predictable, overridable with `::type(id=...)`)
- **Bad**: Undocumented auto-generation that users can't predict or override

Configuration should be discoverable and documented. A user reading `schema.yaml` should understand exactly what types and traits are available.

### Simple, Unambiguous Syntax

The type/object/trait syntax must be:

- **Visually distinct**: `::type()` for objects, `@trait` or `@trait(value)` for traits, `[[ref]]` for links
- **Predictable**: Same syntax always means the same thing
- **Non-conflicting**: Syntax should not collide with common markdown patterns
- **Parseable**: Regular expressions or simple parsers can extract elements reliably

**Traits are single-valued**: Each trait takes at most one value. Use multiple traits instead of one trait with multiple fields: `@due(2025-02-01) @priority(high)` not `@task(due=..., priority=...)`.

Avoid syntax that requires context to interpret or that could be confused with other markdown conventions.

### User-Controlled Schema

Configuration defines everything—nothing is hidden:

- All available types come from `schema.yaml` (plus built-in `page`, `section`, `date`)
- All available traits come from `schema.yaml`
- All saved queries come from `raven.yaml`
- Built-in types:
  - `page` and `section`: Can be customized or extended by the user
  - `date`: Locked (cannot be modified). Used for daily notes (YYYY-MM-DD.md files). Use traits for daily note metadata.
- Vault behavior (daily directory, queries) configured in `raven.yaml`
- Field validation, defaults—all in the schema

**Traits are universal**: Traits defined globally in `schema.yaml` can be used:
- **Inline** anywhere in content: `@due(2025-02-01) Send the report`
- **In frontmatter** if the type declares them: `due: 2025-02-01`

Types declare which traits are valid in their frontmatter using the `traits` field. This enables structured data (frontmatter traits on objects) and flexible annotation (inline traits on content) to coexist.

**No hidden behavior**: If the system does something, it should be traceable to configuration or documented built-in behavior.

### General System, User Workflow

Raven is a **general system** for adding typed structure to markdown:

- **We provide**: Types, traits, references, tags, querying, indexing
- **User decides**: What types to create, what traits to use, folder structure, workflows

Avoid building opinionated workflows into the core:

- **Good**: Atomic traits like `@due`, `@status`, `@priority` that users combine
- **Bad**: Composite `@task` trait that assumes a specific task model
- **Good**: Saved queries in `raven.yaml` that users define for their workflows
- **Bad**: Built-in "task management" with hard-coded status flows
- **Good**: `rvn trait due --value past` for ad-hoc queries
- **Bad**: Built-in "project dashboard" that assumes specific type structures

The tool should be a foundation that users build their workflows on top of.

### Vault-Scoped Operations

**All Raven functionality must operate exclusively within the explicitly identified vault.**

This is a security and integrity principle:

- **File operations**: Read, write, create, delete—only within the vault directory
- **Path validation**: Always verify resolved paths remain within vault boundaries before any operation
- **No escape**: Symlinks, `../` paths, or any mechanism that could reach outside the vault must be blocked
- **Explicit boundaries**: The vault path is set via config or CLI flag—never inferred from current directory alone

Implementation pattern:
```go
// Always validate paths before operations
absVault, _ := filepath.Abs(vaultPath)
absTarget, _ := filepath.Abs(targetPath)
if !strings.HasPrefix(absTarget, absVault+string(filepath.Separator)) {
    return fmt.Errorf("cannot operate outside vault: %s", targetPath)
}
```

This protects users from:
- Accidental writes to system files
- Malicious references escaping the vault
- Unintended side effects from misconfigured paths

## Code Standards

### General Best Practices
- Make sure that core functionality is implemented once, not duplicated. And then reused throughout the app as needed. For example, in an earlier version we had a few different implementations of new page creation -- this should always be a single implementation that is called from different entrypoints as needed

### Go Conventions

- Follow standard Go project layout (`cmd/`, `internal/`)
- Use `go fmt` and `go vet`
- Prefer stdlib where sufficient (e.g., `encoding/json`, `path/filepath`)
- Error messages should be actionable and include context

### Testing

- Unit tests for parser components (frontmatter, markdown, traits, refs)
- Integration tests using `testdata/` vault
- Test edge cases: empty files, malformed syntax, unicode, code blocks

### CLI Design

- Commands should be discoverable via `--help`
- Error messages should suggest fixes
- Output should be human-readable by default, with `--json` for scripting
- Enforce vault-scoped operations (see "Vault-Scoped Operations" above)

## Implementation Checklist

When adding a feature:

1. [ ] Verify feature is documented in `docs/SPECIFICATION.md`
2. [ ] If new, add to spec with rationale in Design Decisions section
3. [ ] Implement with explicit configuration (no magic)
4. [ ] Add tests covering normal and edge cases
5. [ ] Update README.md if user-facing behavior changes
6. [ ] Ensure CLI help text is accurate

When fixing a bug:

1. [ ] Check if spec describes expected behavior
2. [ ] If spec is unclear, clarify it first
3. [ ] Fix code to match spec
4. [ ] Add regression test
